# ==============================================================================
# E8 Cycle Clock: Direct Computational Testing
#
# This script performs direct computational verification of the E8 cycle clock
# dynamics. It determines the true cycle paths for the s, t, and g=st
# operators and the procedural t-s-t... sequence by applying the operator
# matrices directly to the E8 vertex coordinates.
#
# Author: Marcelo Amaral
# Computational Implementation: Google Gemini
# Date: June 30, 2025
# ==============================================================================

import numpy as np

# --- Part 1: Operator and Shell Definitions ---
def get_c5_rotor():
    """Defines the C5 rotation matrix 's' by construction."""
    s_op = np.array([
        [-0.5,  0.5,  0.0,  0.0,  0.0,  0.0,  0.5,  0.5],
        [-0.5, -0.5,  0.0,  0.0,  0.0,  0.0,  0.5, -0.5],
        [ 0.0,  0.0, -0.5,  0.5, -0.5, -0.5,  0.0,  0.0],
        [ 0.0,  0.0, -0.5, -0.5, -0.5,  0.5,  0.0,  0.0],
        [-0.5,  0.5,  0.0,  0.0,  0.0,  0.0, -0.5, -0.5],
        [-0.5, -0.5,  0.0,  0.0,  0.0,  0.0, -0.5,  0.5],
        [ 0.0,  0.0, -0.5,  0.5,  0.5,  0.5,  0.0,  0.0],
        [ 0.0,  0.0, -0.5, -0.5,  0.5, -0.5,  0.0,  0.0]
    ])
    return s_op.T

def get_c2_rotor():
    """Defines the C2 swap operator 't' by construction."""
    return np.block([
        [np.zeros((4, 4)), np.identity(4)],
        [np.identity(4), np.zeros((4, 4))]
    ])

def generate_e8_shell_partition(c5_rotor):
    """Generates the 10 D4-shells of E8 using the C5 rotor."""
    print("Generating E8 shell partition...")
    d4_roots = set()
    for i in range(4):
        for j in range(i + 1, 4):
            for s1 in [-1, 1]:
                for s2 in [-1, 1]:
                    q = np.zeros(4); q[i], q[j] = s1, s2
                    d4_roots.add(tuple(q))
    d4_roots = np.array(list(d4_roots))

    seed_a = np.hstack([d4_roots, np.zeros((24, 4))])
    seed_b = np.hstack([np.zeros((24, 4)), d4_roots])

    shells_a = [seed_a @ np.linalg.matrix_power(c5_rotor, k) for k in range(5)]
    shells_b = [seed_b @ np.linalg.matrix_power(c5_rotor, k) for k in range(5)]

    final_shells = [item for pair in zip(shells_a, shells_b) for item in pair]
    print("Shell partition generated successfully.")
    return final_shells

# --- Part 2: Direct Computational Test Functions ---

def find_true_cycle(op, op_name, start_vec, vec_map):
    """
    Computes the exact cycle for a single operator by repeatedly applying
    the matrix until the start vector is recovered.
    """
    print(f"\n## Testing Operator: {op_name}")
    start_vec_int = tuple(np.round(start_vec * 2).astype(int))
    path_indices = [vec_map[start_vec_int]]
    current_vec = np.copy(start_vec)

    for i in range(1, 21): # Loop for a reasonable number of steps
        current_vec = op @ current_vec
        current_vec_int = tuple(np.round(current_vec * 2).astype(int))
        path_indices.append(vec_map[current_vec_int])

        if np.allclose(current_vec, start_vec, atol=1e-9):
            print(f"  - **Path:** `{' -> '.join(map(str, path_indices))}`")
            print(f"  - **Unique Shells Visited:** {len(set(path_indices[:-1]))}")
            print(f"  - **Result:** Found a cycle of length **{i}**.")
            return

    print(f"  - **Result:** No cycle found within {len(path_indices)-1} steps.")

def trace_procedural_clock(s_op, t_op, start_vec, vec_map):
    """
    Computes the path generated by an alternating t -> s -> t -> s... sequence.
    """
    print("\n## Testing: Procedural Clock (t -> s -> t -> ...)")
    start_vec_int = tuple(np.round(start_vec * 2).astype(int))
    path_indices = [vec_map[start_vec_int]]
    current_vec = np.copy(start_vec)

    # We expect a 10-cycle, so we trace for 10 steps
    for i in range(10):
        # Step 1 (i=0): t, Step 2 (i=1): s, Step 3 (i=2): t, ...
        op, op_name = (t_op, 't') if i % 2 == 0 else (s_op, 's')
        current_vec = op @ current_vec
        path_indices.append(vec_map[tuple(np.round(current_vec * 2).astype(int))])

    print(f"  - **Path:** `{' -> '.join(map(str, path_indices))}`")
    print(f"  - **Unique Shells Visited:** {len(set(path_indices[:-1]))}")

    if len(set(path_indices[:-1])) == 10:
        print("  - **Result:** The procedural clock is **transitive** and visits all 10 shells.")
    else:
        print("  - **Result:** The procedural clock is **not transitive**.")


# --- Part 3: Main Execution ---

if __name__ == "__main__":
    # 1. Setup operators and E8 vertex data
    s_rotor = get_c5_rotor()
    t_rotor = get_c2_rotor()
    g_rotor = s_rotor @ t_rotor # g = st
    
    LAMBDA = generate_e8_shell_partition(s_rotor)
    vec_map = {tuple(np.round(v * 2).astype(int)): idx for idx, s in enumerate(LAMBDA) for v in s}
    start_vector = LAMBDA[0][0]

    print("\n" + "="*70)
    print("      E8 CLOCK: DIRECT COMPUTATIONAL TEST RESULTS")
    print("="*70)

    # 2. Run the computational tests
    find_true_cycle(s_rotor, "'s' (C5 Rotor)", start_vector, vec_map)
    print("-" * 70)
    find_true_cycle(t_rotor, "'t' (C2 Swap)", start_vector, vec_map)
    print("-" * 70)
    find_true_cycle(g_rotor, "'g = st' (Composite Rotor)", start_vector, vec_map)
    print("-" * 70)
    trace_procedural_clock(s_rotor, t_rotor, start_vector, vec_map)
    print("="*70)